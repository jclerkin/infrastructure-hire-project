import boto3
import json
import csv
from datetime import datetime
import os
import time

# Set variables
kms_key_id = os.environ['kms_key_id']
polling_timeout = os.environ['polling_timeout']
queue_url = os.environ['queue_url']
aws_region = os.environ['region']

s3 = boto3.client('s3')
s3_resource = boto3.resource('s3')
sqs = boto3.client('sqs', region_name=aws_region)

while 1:
    try:
        date = datetime.today().strftime("%Y-%m-%d")
        # Pull message from SQS
        message_str = sqs.receive_message(QueueUrl=queue_url)['Messages'][0]
        sqs_receipt = message_str['ReceiptHandle']
        message = json.loads(message_str['Body'])
        # Get object details
        bucket = message.get('bucket')
        key = message.get('key')
        # Set results filename
        filename = os.path.splitext(os.path.basename(key))[0]
        result_filename = 'outbound/' + filename + str(date) + '.csv'

        # Print object being pulled from S3
        print('Getting object s3://' + bucket + '/' + key)

        # Retrieve data
        document = s3.get_object(Bucket=bucket, Key=key)
        contents = document['Body'].read().decode()
        data = json.loads(contents)

        # get the number of vulnerabilities being reported
        l = data['vulnerabilities']
        c = len(l)

        # get the number of vendors we are looking for
        vendor_ids = []
        item = 0
        while item < c:
            vendor_ids.append(int(data['vulnerabilities'][item]['vendor_id']))
            item = item + 1

        # Get the max and min values for vendor_id
        max_vendor_id = max(vendor_ids)
        min_vendor_id = min(vendor_ids)

        # Start loop with the minimum value for vendor idea
        vendor = min_vendor_id

        # Count security vulnerabilites per vendor id and add to results.csv
        item = 0
        with open('results.csv', 'w', newline='') as csvfile:
            fieldnames = ['Vendor_id', 'LOW', 'MEDIUM', 'HIGH']
            writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
            writer.writerow({'Vendor_id': "Vendor_id", 'LOW': 'LOW', 'MEDIUM': 'MEDIUM', 'HIGH': 'MEDIUM'})
            while vendor <= max_vendor_id:
                low = 0
                med = 0
                high = 0
                print('Searching for vulnerabilities for vendor ' + str(vendor))
                for i in data['vulnerabilities']:
                    if vendor == int(data['vulnerabilities'][item]['vendor_id']) and data['vulnerabilities'][item]['severity'] == "LOW":
                        low = low + 1
                        item = item + 1
                    elif vendor == int(data['vulnerabilities'][item]['vendor_id']) and data['vulnerabilities'][item]['severity'] == "MEDIUM":
                        med = med + 1
                        item = item + 1
                    elif vendor == int(data['vulnerabilities'][item]['vendor_id']) and data['vulnerabilities'][item]['severity'] == "HIGH":
                        high = high + 1
                        item = item + 1
                    else:
                        item = item + 1
                print(
                    'Vulerabilities detected for vendor ' + str(vendor) + '\n' +
                    'LOW: ' + str(low) + '\n' +
                    'MEDIUM: ' + str(med) + '\n' +
                    'HIGH: ' + str(high)
                )

                writer.writerow({'Vendor_id': str(vendor), 'LOW': str(low), 'MEDIUM': str(med), 'HIGH': str(high)})
                item = 0
                vendor = vendor + 1

            s3_resource.meta.client.upload_file('results.csv', bucket, result_filename, ExtraArgs={"ServerSideEncryption": "aws:kms", "SSEKMSKeyId": kms_key_id})

            sqs.delete_message(
                QueueUrl=queue_url,
                ReceiptHandle=sqs_receipt
            )

            time.sleep(int(polling_timeout))

    # If SQS is empty
    except KeyError:
        print('No messages on the queue!')
        time.sleep(int(polling_timeout))
